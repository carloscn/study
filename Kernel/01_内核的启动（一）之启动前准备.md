# 01_Linux内核的启动（一）之启动前准备

在广州市图书馆偶然间看到尹锡训 -《ARM Linux内核源码剖析》（코드로 알아보는 ARM 리눅스 커널）[^1]，这个书我觉得非常适合我现在看。本书涉及Linux内核启动和处理，紧密和ARM架构机制相结合，一方面可以加深对ARM硬件机制的理解，另一方面能够科普Linux内核内设机制，作为Linux内核机制的入门，相当于从ARM迈入Linux的桥梁。本书需要结合ARM手册和Linux内核两本书同时参考。

![](https://raw.githubusercontent.com/makelinux/linux_kernel_map/main/LKM.svg)

# 1. 内核构建系统

操作系统必然是一个非常庞大和复杂的系统[^2]。由调度程序、文件系统、内存管理、网络系统等诸多子系统组成。这种内核十分庞大，**但是其生成只需要一个二进制启动文件**（zImage/bzImage）。可以将**zImage文件就视为内核elf文件**。

<div align='center'>
<img src="https://raw.githubusercontent.com/carloscn/images/main/typoratelegram-cloud-document-5-6206454177690813831.jpg" width="80%" />
</div>

## 1.1 内核初始化和配置

内核初始化状态是从kernel.org下载的tar.gz内核源程序压缩包，解压之后为内核源码的代码树，这种状态叫做**内核的初始状态**。

使用`make mrproper`和 `make distclean`等指令可以内核源码恢复到内核初始状态。注意：

*   执行mrproper编译指令，只清除.config文件在内的为内核编译级链接而生成的诸多设置文件。
*   执行distclean编译指令，清除内核编译后生成的所有对象文件、备份文件。

内核在初始状态不可以直接编译，虽然可以生成vmlinux（没有压缩的内核文件[^3]），但大部分情况会引起**内核严重错误(kernel panic)**。因此，需要执行最重要、最需要谨慎处理的**内核配置（kernel configuration）**的过程，也是生成编译必要.config文件的过程。注意：

*   xconfig：基于Qt的前端的配置
*   menuconfig： 基于终端的menu配置
*   gconfig：基于GTK的前端的配置

**kernel的配置的单位是 SoC级的**

## 1.2 内核的构建和安装

生成.config文件之后，就可以开始**构建内核（kernel building）**，相当于从**kernel源代码 -> zImage的过程**。如果從kernel編譯過程來看vmlinux是如何組成的話[^4]：

```bash
make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- zImage -j4
(....)
  LD      vmlinux
  SORTEX  vmlinux
  SYSMAP  System.map
  OBJCOPY arch/arm/boot/Image
  Kernel: arch/arm/boot/Image is ready
  Kernel: arch/arm/boot/Image is ready
  LDS     arch/arm/boot/compressed/vmlinux.lds
  AS      arch/arm/boot/compressed/head.o
  GZIP    arch/arm/boot/compressed/piggy.gzip
  CC      arch/arm/boot/compressed/misc.o
  CC      arch/arm/boot/compressed/decompress.o
  CC      arch/arm/boot/compressed/string.o
  AS      arch/arm/boot/compressed/lib1funcs.o
  AS      arch/arm/boot/compressed/ashldi3.o
  AS      arch/arm/boot/compressed/bswapsdi2.o
  AS      arch/arm/boot/compressed/piggy.gzip.o
  LD      arch/arm/boot/compressed/vmlinux
  OBJCOPY arch/arm/boot/zImage
  Kernel: arch/arm/boot/zImage is ready
```

這裡列出比較重要的幾個：

| 檔案                                                     | 功能                                                         | RPi source                                |
| :------------------------------------------------------- | :----------------------------------------------------------- | :---------------------------------------- |
| `vmlinux`                                                | `vmlinux`是ELF格式binary檔案，為最原始也未壓縮的kernel鏡像。 | `./vmlinux`                               |
| [`System.map`](https://zh.wikipedia.org/wiki/System.map) | 在符號名稱與它們的記憶體位置間的查詢表格                     | `./System.map`                            |
| `Image`                                                  | `vmlinux`經過[`objcopy`](http://stackoverflow.com/questions/19944441/make-executable-binary-file-from-elf-using-gnu-objcopy)處理，把代碼從中抽出(去除註解或debugging symbols)以用於形成可執行的機器碼。不過`Image`此時還不能直接執行，需加入metadata資訊。 | `./arch/arm/boot/Image`                   |
| `head.o`                                                 | ARM特有的code，用來接受從bootloader送來的系統控制權，source code `head.S`是用組語(arm-assembly)寫成。 | `./arch/arm/boot/compressed/head.S`       |
| `piggy.gzip`                                             | 被gzip壓縮的Image                                            | `./arch/arm/boot/compressed/piggy.gzip`   |
| `piggy.gzip.o`                                           | 用組語寫成，可被用來連結到別的物件，例如`piggy.gzip`。       | `./arch/arm/boot/compressed/piggy.gzip.S` |
| `misc.o`                                                 | 用來解壓縮。                                                 | `./arch/arm/boot/compressed/misc.c`       |
| `compressed/vmlinux`                                     | 結合`System.map`等檔案並產生鏡像檔，意義跟一開始的`vmlinux`不太一樣。 | `./arch/arm/boot/compressed/vmlinux`      |
| `zImage`                                                 | 最後產生的鏡像檔，已經被壓縮過。                             | `./arch/arm/boot/zImage`                  |

<div align='center'>
<img src="https://raw.githubusercontent.com/carloscn/images/main/typoratelegram-cloud-document-5-6206454177690813841.jpg" width="80%" />
</div>

vmlinux是ELF格式的二进制映像，由文件系统、网络、设备驱动及调度程序组成，是zimage之前的原始文件，构建内核过程均需要各个部件通过linker组合成一个名为vmlinux的较大的ELF格式对象文件。[图源于链接](https://github.com/carloscn/doclib/blob/master/ppt/kernel/decompressed-vmlinux-linux-kernel-initialization-from-page-table-configuration-perspective.pdf)[^5]

![image-20220705123358771](https://raw.githubusercontent.com/carloscn/images/main/typoraimage-20220705123358771.png)

编译后的内核会生成ELF格式的二进制文件vmlinux，具备内核的所有要素。vmlinux通过gzip压缩成为piggy.o和head.o, misc.o执行链接，最后生成zImage二进制文件。内核的内存加载及执行都能通过zImage提高速度，特别是head.o和misc.o相当于引导程序加载项。

**内核最后安装生成与/boot文件夹下**。

# 2. 解压内核 decompressed kernel

内核实际的启动节点是`start_kernel()`函数，在这个调用中再去调用100多个子函数执行linux的启动。但是调用start_kernel之前，也有一部分工作要处理：

*   必须对zImage进行解压
*   完成页目录构建（处理器列表、MMU目录建立、激活MMU）
*   检查处理器信息（atag信息有消息）

本章以ARMv7和ARMv8架构为例子，研究Linux内核启动前准备。

## 2.1 zImage pre-decompressed

zImage在开始前，需要对处理器进行一些初始化操作，为解压做一些准备。这个过程包含：中断禁止、分配动态内存、初始化BSS区、初始化页目录、打开cache等任务。然后后面会为解压数据进行空间数据（页目录空间）。

<div align='center'>
<img src="https://raw.githubusercontent.com/carloscn/images/main/typoratelegram-cloud-document-5-6206454177690813892.jpg" width="60%" />
</div>

### 2.1.1 ARMv7

#### 2.1.1.1 start标签

通过启动加载项完成对软硬件的默认初始化任务之后，最先执行的是`arch/arm/boot/compressed/head.S`，代码如下[arch/arm/boot/compressed/head.S](https://github.com/Xilinx/linux-xlnx/blob/master/arch/arm/boot/compressed/head.S#L192) 。start标签是第一个执行的代码，在start标签中，从启动加载项接手ID和atags的信息。此外，还会禁用中断及初始化寄存器，并跳转到[not_relocated](https://github.com/Xilinx/linux-xlnx/blob/master/arch/arm/boot/compressed/head.S#L192)标签(用于初始化bss)。

```
LCO -> r1
__bss_start -> r2
_end -> r3
zreladdr -> r4
_start -> r5
_got_start ->r6
_got_end -> ip
user_stack + 4096 -> sp
```

#### 2.1.1.2 bss系统域初始化- not_relocated标签

```assembly
not_relocated:	mov	r0, #0
1:		str	r0, [r2], #4		@ clear bss
		str	r0, [r2], #4
		str	r0, [r2], #4
		str	r0, [r2], #4
		cmp	r2, r3
		blo	1b

		/*
		 * Did we skip the cache setup earlier?
		 * That is indicated by the LSB in r4.
		 * Do it now if so.
		 */
		tst	r4, #1
		bic	r4, r4, #1
		blne	cache_on @将用于内核的动态内存空间起始地址
```

#### 2.1.1.3 激活缓存-cache_on

如果已经完成了bss区域的初始化和动态区域的设置，解压内核的最后准备就是执行cache_on。Linux中的cacheon的实现方式根据arm的机构版本不同是不同的。在cache_on标签中查找并调用当前系统ARM结构版本相符程序的子程序，另外，调用__setup_mmu子程序对页目录进行初始化。

```assembly
/*
 * Turn on the cache.  We need to setup some page tables so that we
 * can have both the I and D caches on.
 *
 * We place the page tables 16k down from the kernel execution address,
 * and we hope that nothing else is using it.  If we're using it, we
 * will go pop!
 *
 * On entry,
 *  r4 = kernel execution address
 *  r7 = architecture number
 *  r8 = atags pointer
 * On exit,
 *  r0, r1, r2, r3, r9, r10, r12 corrupted
 * This routine must preserve:
 *  r4, r7, r8
 */
		.align	5
cache_on:	mov	r3, #8			@ cache_on function
		b	call_cache_fn

/*
 * Initialize the highest priority protection region, PR7
 * to cover all 32bit address and cacheable and bufferable.
 */
__armv4_mpu_cache_on:
		mov	r0, #0x3f		@ 4G, the whole
		mcr	p15, 0, r0, c6, c7, 0	@ PR7 Area Setting
		mcr 	p15, 0, r0, c6, c7, 1

		mov	r0, #0x80		@ PR7
		mcr	p15, 0, r0, c2, c0, 0	@ D-cache on
		mcr	p15, 0, r0, c2, c0, 1	@ I-cache on
		mcr	p15, 0, r0, c3, c0, 0	@ write-buffer on

		mov	r0, #0xc000
		mcr	p15, 0, r0, c5, c0, 1	@ I-access permission
		mcr	p15, 0, r0, c5, c0, 0	@ D-access permission

		mov	r0, #0
		mcr	p15, 0, r0, c7, c10, 4	@ drain write buffer
		mcr	p15, 0, r0, c7, c5, 0	@ flush(inval) I-Cache
		mcr	p15, 0, r0, c7, c6, 0	@ flush(inval) D-Cache
		mrc	p15, 0, r0, c1, c0, 0	@ read control reg
						@ ...I .... ..D. WC.M
		orr	r0, r0, #0x002d		@ .... .... ..1. 11.1
		orr	r0, r0, #0x1000		@ ...1 .... .... ....

		mcr	p15, 0, r0, c1, c0, 0	@ write control reg

		mov	r0, #0
		mcr	p15, 0, r0, c7, c5, 0	@ flush(inval) I-Cache
		mcr	p15, 0, r0, c7, c6, 0	@ flush(inval) D-Cache
		mov	pc, lr

__armv3_mpu_cache_on:
		mov	r0, #0x3f		@ 4G, the whole
		mcr	p15, 0, r0, c6, c7, 0	@ PR7 Area Setting

		mov	r0, #0x80		@ PR7
		mcr	p15, 0, r0, c2, c0, 0	@ cache on
		mcr	p15, 0, r0, c3, c0, 0	@ write-buffer on

		mov	r0, #0xc000
		mcr	p15, 0, r0, c5, c0, 0	@ access permission

		mov	r0, #0
		mcr	p15, 0, r0, c7, c0, 0	@ invalidate whole cache v3
		/*
		 * ?? ARMv3 MMU does not allow reading the control register,
		 * does this really work on ARMv3 MPU?
		 */
		mrc	p15, 0, r0, c1, c0, 0	@ read control reg
						@ .... .... .... WC.M
		orr	r0, r0, #0x000d		@ .... .... .... 11.1
		/* ?? this overwrites the value constructed above? */
		mov	r0, #0
		mcr	p15, 0, r0, c1, c0, 0	@ write control reg

		/* ?? invalidate for the second time? */
		mcr	p15, 0, r0, c7, c0, 0	@ invalidate whole cache v3
		mov	pc, lr

#ifdef CONFIG_CPU_DCACHE_WRITETHROUGH
#define CB_BITS 0x08
#else
#define CB_BITS 0x0c
#endif
```

#### 2.1.1.4 页表项初始化 - __setup_mmu

__setup_mmu标签在cache_on标签内部调用，用于初始化解压内核的页表项。特别是对内存的256MB区域设置cacheable, bufferable，这是因为解压内核的时候，使用cache和writebuffer提高解压性能。

![image-20220705150241288](https://raw.githubusercontent.com/carloscn/images/main/typoraimage-20220705150241288.png)

```assembly
__setup_mmu:	sub	r3, r4, #16384		@ Page directory size
		bic	r3, r3, #0xff		@ Align the pointer
		bic	r3, r3, #0x3f00
/*
 * Initialise the page tables, turning on the cacheable and bufferable
 * bits for the RAM area only.
 */
		mov	r0, r3
		mov	r9, r0, lsr #18
		mov	r9, r9, lsl #18		@ start of RAM
		add	r10, r9, #0x10000000	@ a reasonable RAM size
		mov	r1, #0x12		@ XN|U + section mapping
		orr	r1, r1, #3 << 10	@ AP=11
		add	r2, r3, #16384
1:		cmp	r1, r9			@ if virt > start of RAM
		cmphs	r10, r1			@   && end of RAM > virt
		bic	r1, r1, #0x1c		@ clear XN|U + C + B
		orrlo	r1, r1, #0x10		@ Set XN|U for non-RAM
		orrhs	r1, r1, r6		@ set RAM section settings
		str	r1, [r0], #4		@ 1:1 mapping
		add	r1, r1, #1048576
		teq	r0, r2
		bne	1b
/*
 * If ever we are running from Flash, then we surely want the cache
 * to be enabled also for our execution instance...  We map 2MB of it
 * so there is no map overlap problem for up to 1 MB compressed kernel.
 * If the execution is in RAM then we would only be duplicating the above.
 */
		orr	r1, r6, #0x04		@ ensure B is set for this
		orr	r1, r1, #3 << 10
		mov	r2, pc
		mov	r2, r2, lsr #20
		orr	r1, r1, r2, lsl #20
		add	r0, r3, r2, lsl #2
		str	r1, [r0], #4
		add	r1, r1, #1048576
		str	r1, [r0]
		mov	pc, lr
ENDPROC(__setup_mmu)

@ Enable unaligned access on v6, to allow better code generation
@ for the decompressor C code:
__armv6_mmu_cache_on:
		mrc	p15, 0, r0, c1, c0, 0	@ read SCTLR
		bic	r0, r0, #2		@ A (no unaligned access fault)
		orr	r0, r0, #1 << 22	@ U (v6 unaligned access model)
		mcr	p15, 0, r0, c1, c0, 0	@ write SCTLR
		b	__armv4_mmu_cache_on

__arm926ejs_mmu_cache_on:
#ifdef CONFIG_CPU_DCACHE_WRITETHROUGH
		mov	r0, #4			@ put dcache in WT mode
		mcr	p15, 7, r0, c15, c0, 0
#endif

__armv4_mmu_cache_on:
		mov	r12, lr
#ifdef CONFIG_MMU
		mov	r6, #CB_BITS | 0x12	@ U
		bl	__setup_mmu
		mov	r0, #0
		mcr	p15, 0, r0, c7, c10, 4	@ drain write buffer
		mcr	p15, 0, r0, c8, c7, 0	@ flush I,D TLBs
		mrc	p15, 0, r0, c1, c0, 0	@ read control reg
		orr	r0, r0, #0x5000		@ I-cache enable, RR cache replacement
		orr	r0, r0, #0x0030
 ARM_BE8(	orr	r0, r0, #1 << 25 )	@ big-endian page tables
		bl	__common_mmu_cache_on
		mov	r0, #0
		mcr	p15, 0, r0, c8, c7, 0	@ flush I,D TLBs
#endif
		mov	pc, r12

__armv7_mmu_cache_on:
		enable_cp15_barriers	r11
		mov	r12, lr
#ifdef CONFIG_MMU
		mrc	p15, 0, r11, c0, c1, 4	@ read ID_MMFR0
		tst	r11, #0xf		@ VMSA
		movne	r6, #CB_BITS | 0x02	@ !XN
		blne	__setup_mmu
		mov	r0, #0
		mcr	p15, 0, r0, c7, c10, 4	@ drain write buffer
		tst	r11, #0xf		@ VMSA
		mcrne	p15, 0, r0, c8, c7, 0	@ flush I,D TLBs
#endif
		mrc	p15, 0, r0, c1, c0, 0	@ read control reg
		bic	r0, r0, #1 << 28	@ clear SCTLR.TRE
		orr	r0, r0, #0x5000		@ I-cache enable, RR cache replacement
		orr	r0, r0, #0x003c		@ write buffer
		bic	r0, r0, #2		@ A (no unaligned access fault)
		orr	r0, r0, #1 << 22	@ U (v6 unaligned access model)
						@ (needed for ARM1176)
#ifdef CONFIG_MMU
 ARM_BE8(	orr	r0, r0, #1 << 25 )	@ big-endian page tables
		mrcne   p15, 0, r6, c2, c0, 2   @ read ttb control reg
		orrne	r0, r0, #1		@ MMU enabled
		movne	r1, #0xfffffffd		@ domain 0 = client
		bic     r6, r6, #1 << 31        @ 32-bit translation system
		bic     r6, r6, #(7 << 0) | (1 << 4)	@ use only ttbr0
		mcrne	p15, 0, r3, c2, c0, 0	@ load page table pointer
		mcrne	p15, 0, r1, c3, c0, 0	@ load domain access control
		mcrne   p15, 0, r6, c2, c0, 2   @ load ttb control
#endif
		mcr	p15, 0, r0, c7, c5, 4	@ ISB
		mcr	p15, 0, r0, c1, c0, 0	@ load control register
		mrc	p15, 0, r0, c1, c0, 0	@ and read it back
		mov	r0, #0
		mcr	p15, 0, r0, c7, c5, 4	@ ISB
		mov	pc, r12

__fa526_cache_on:
		mov	r12, lr
		mov	r6, #CB_BITS | 0x12	@ U
		bl	__setup_mmu
		mov	r0, #0
		mcr	p15, 0, r0, c7, c7, 0	@ Invalidate whole cache
		mcr	p15, 0, r0, c7, c10, 4	@ drain write buffer
		mcr	p15, 0, r0, c8, c7, 0	@ flush UTLB
		mrc	p15, 0, r0, c1, c0, 0	@ read control reg
		orr	r0, r0, #0x1000		@ I-cache enable
		bl	__common_mmu_cache_on
		mov	r0, #0
		mcr	p15, 0, r0, c8, c7, 0	@ flush UTLB
		mov	pc, r12

__common_mmu_cache_on:
#ifndef CONFIG_THUMB2_KERNEL
#ifndef DEBUG
		orr	r0, r0, #0x000d		@ Write buffer, mmu
#endif
		mov	r1, #-1
		mcr	p15, 0, r3, c2, c0, 0	@ load page table pointer
		mcr	p15, 0, r1, c3, c0, 0	@ load domain access control
		b	1f
		.align	5			@ cache line aligned
1:		mcr	p15, 0, r0, c1, c0, 0	@ load control register
		mrc	p15, 0, r0, c1, c0, 0	@ and read it back to
		sub	pc, lr, r0, lsr #32	@ properly flush pipeline
#endif
```

### 2.1.2 ARMv8

**在ARMv8中已经drop掉了关于对Linux内核解压的部分**，实际上可以在arch/arm64/boot/的下面看不到了compressed/head.S的身影了。这部分原因我们可以在booting arch64里面可以看到说明[^6]：

>```
>3. Decompress the kernel image
>------------------------------
>
>Requirement: OPTIONAL
>
>The AArch64 kernel does not currently provide a decompressor and
>therefore requires decompression (gzip etc.) to be performed by the boot
>loader if a compressed Image target (e.g. Image.gz) is used.  For
>bootloaders that do not implement this requirement, the uncompressed
>Image target is available instead.
>```

基本的意思是在arm64内核的下面不再默认提供解压工具，如果有需要需要在boot组件中实现。那么相应的，在AArch64 kernel image decompression的一封信件中，可以找到uboot的确是对aarch64这块重新做了支持[^7]。更多的工程师也倾向于拿掉内核的压缩和解压部分，甚至对uboot的uImage压缩提出了挑战设计。笔者认为，在arch64这样的高性能架构，已经无需在对vmlinux的大小做太多的考虑，可能只有在arch64一些size sensitive的情境下面才需要进行压缩。

而且，在linux kernel里面存在两个head.S也十分让人费解。在ARMv7的手册里还对这部分做了解释[^8]，arch/arm/boot/compressed/head.S和arch/arm/kernel/head.S，前者主要是对在early-boot阶段对zImage的解压，对vmlinux的还原。的确，去掉更好，更有助于消除内核歧义。


# Ref

[^1]: [ARM Linux内核源码剖析](https://book.douban.com/subject/25918026/)
[^2]:[Linux Kernel Map](https://makelinux.github.io/kernel/map/)
[^3]:[几种linux内核文件的区别(vmlinux、zImage、bzImage、uImage、vmlinuz、initrd ) ](https://blog.csdn.net/hanxuefan/article/details/7454352)
[^4]:[Chapter 5 : Kernel Initialization ](https://hackmd.io/@3zUb5pYSS1W_VVsmvHE5MQ/BJroQrL-g?type=view)
[^5]:[Decompressed vmlinux: linux kernel initialization from page table configuration perspective](https://www.slideshare.net/AdrianHuang/decompressed-vmlinux-linux-kernel-initialization-from-page-table-configuration-perspective)
[^6]:[Booting AArch64 Linux](https://www.kernel.org/doc/Documentation/arm64/booting.txt)
[^7]:[AArch64 kernel image decompression](https://linux-arm-kernel.infradead.narkive.com/bcdVuTBY/aarch64-kernel-image-decompression)
[^8]:[ARM Cortex-A Series Programmer's Guide for ARMv7-A - Kernel entry](https://developer.arm.com/documentation/den0013/d/Boot-Code/Booting-Linux/Kernel-entry)