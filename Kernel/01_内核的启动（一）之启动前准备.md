# 01_Linux内核的启动（一）之启动前准备

在广州市图书馆偶然间看到尹锡训 -《ARM Linux内核源码剖析》（코드로 알아보는 ARM 리눅스 커널）[^1]，这个书我觉得非常适合我现在看。本书涉及Linux内核启动和处理，紧密和ARM架构机制相结合，一方面可以加深对ARM硬件机制的理解，另一方面能够科普Linux内核内设机制，作为Linux内核机制的入门，相当于从ARM迈入Linux的桥梁。本书需要结合ARM手册和Linux内核两本书同时参考。

![](https://raw.githubusercontent.com/makelinux/linux_kernel_map/main/LKM.svg)

# 1. 内核构建系统

操作系统必然是一个非常庞大和复杂的系统[^2]。由调度程序、文件系统、内存管理、网络系统等诸多子系统组成。这种内核十分庞大，**但是其生成只需要一个二进制启动文件**（zImage/bzImage）。可以将**zImage文件就视为内核elf文件**。

<div align='center'>
<img src="https://raw.githubusercontent.com/carloscn/images/main/typoratelegram-cloud-document-5-6206454177690813831.jpg" width="80%" />
</div>

## 1.1 内核初始化和配置

内核初始化状态是从kernel.org下载的tar.gz内核源程序压缩包，解压之后为内核源码的代码树，这种状态叫做**内核的初始状态**。

使用`make mrproper`和 `make distclean`等指令可以内核源码恢复到内核初始状态。注意：

*   执行mrproper编译指令，只清除.config文件在内的为内核编译级链接而生成的诸多设置文件。
*   执行distclean编译指令，清除内核编译后生成的所有对象文件、备份文件。

内核在初始状态不可以直接编译，虽然可以生成vmlinux（没有压缩的内核文件[^3]），但大部分情况会引起**内核严重错误(kernel panic)**。因此，需要执行最重要、最需要谨慎处理的**内核配置（kernel configuration）**的过程，也是生成编译必要.config文件的过程。注意：

*   xconfig：基于Qt的前端的配置
*   menuconfig： 基于终端的menu配置
*   gconfig：基于GTK的前端的配置

**kernel的配置的单位是 SoC级的**

## 1.2 内核的构建和安装

生成.config文件之后，就可以开始**构建内核（kernel building）**，相当于从**kernel源代码 -> zImage的过程**。如果從kernel編譯過程來看vmlinux是如何組成的話[^4]：

```bash
make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- zImage -j4
(....)
  LD      vmlinux
  SORTEX  vmlinux
  SYSMAP  System.map
  OBJCOPY arch/arm/boot/Image
  Kernel: arch/arm/boot/Image is ready
  Kernel: arch/arm/boot/Image is ready
  LDS     arch/arm/boot/compressed/vmlinux.lds
  AS      arch/arm/boot/compressed/head.o
  GZIP    arch/arm/boot/compressed/piggy.gzip
  CC      arch/arm/boot/compressed/misc.o
  CC      arch/arm/boot/compressed/decompress.o
  CC      arch/arm/boot/compressed/string.o
  AS      arch/arm/boot/compressed/lib1funcs.o
  AS      arch/arm/boot/compressed/ashldi3.o
  AS      arch/arm/boot/compressed/bswapsdi2.o
  AS      arch/arm/boot/compressed/piggy.gzip.o
  LD      arch/arm/boot/compressed/vmlinux
  OBJCOPY arch/arm/boot/zImage
  Kernel: arch/arm/boot/zImage is ready
```

這裡列出比較重要的幾個：

| 檔案                                                     | 功能                                                         | RPi source                                |
| :------------------------------------------------------- | :----------------------------------------------------------- | :---------------------------------------- |
| `vmlinux`                                                | `vmlinux`是ELF格式binary檔案，為最原始也未壓縮的kernel鏡像。 | `./vmlinux`                               |
| [`System.map`](https://zh.wikipedia.org/wiki/System.map) | 在符號名稱與它們的記憶體位置間的查詢表格                     | `./System.map`                            |
| `Image`                                                  | `vmlinux`經過[`objcopy`](http://stackoverflow.com/questions/19944441/make-executable-binary-file-from-elf-using-gnu-objcopy)處理，把代碼從中抽出(去除註解或debugging symbols)以用於形成可執行的機器碼。不過`Image`此時還不能直接執行，需加入metadata資訊。 | `./arch/arm/boot/Image`                   |
| `head.o`                                                 | ARM特有的code，用來接受從bootloader送來的系統控制權，source code `head.S`是用組語(arm-assembly)寫成。 | `./arch/arm/boot/compressed/head.S`       |
| `piggy.gzip`                                             | 被gzip壓縮的Image                                            | `./arch/arm/boot/compressed/piggy.gzip`   |
| `piggy.gzip.o`                                           | 用組語寫成，可被用來連結到別的物件，例如`piggy.gzip`。       | `./arch/arm/boot/compressed/piggy.gzip.S` |
| `misc.o`                                                 | 用來解壓縮。                                                 | `./arch/arm/boot/compressed/misc.c`       |
| `compressed/vmlinux`                                     | 結合`System.map`等檔案並產生鏡像檔，意義跟一開始的`vmlinux`不太一樣。 | `./arch/arm/boot/compressed/vmlinux`      |
| `zImage`                                                 | 最後產生的鏡像檔，已經被壓縮過。                             | `./arch/arm/boot/zImage`                  |

<div align='center'>
<img src="https://raw.githubusercontent.com/carloscn/images/main/typoratelegram-cloud-document-5-6206454177690813841.jpg" width="80%" />
</div>

vmlinux是ELF格式的二进制映像，由文件系统、网络、设备驱动及调度程序组成，是zimage之前的原始文件，构建内核过程均需要各个部件通过linker组合成一个名为vmlinux的较大的ELF格式对象文件。[图源于链接](https://github.com/carloscn/doclib/blob/master/ppt/kernel/decompressed-vmlinux-linux-kernel-initialization-from-page-table-configuration-perspective.pdf)[^5]

![image-20220705123358771](https://raw.githubusercontent.com/carloscn/images/main/typoraimage-20220705123358771.png)

编译后的内核会生成ELF格式的二进制文件vmlinux，具备内核的所有要素。vmlinux通过gzip压缩成为piggy.o和head.o, misc.o执行链接，最后生成zImage二进制文件。内核的内存加载及执行都能通过zImage提高速度，特别是head.o和misc.o相当于引导程序加载项。

**内核最后安装生成与/boot文件夹下**。

# 2. 解压内核 decompressed kernel (ARMv7 only)

## 2.1 ARMv8

**在ARMv8中已经drop掉了关于对Linux内核解压的部分**，实际上可以在arch/arm64/boot/的下面看不到了compressed/head.S的身影了。这部分原因我们可以在booting arch64里面可以看到说明[^6]：

>```
>3. Decompress the kernel image
>------------------------------
>
>Requirement: OPTIONAL
>
>The AArch64 kernel does not currently provide a decompressor and
>therefore requires decompression (gzip etc.) to be performed by the boot
>loader if a compressed Image target (e.g. Image.gz) is used.  For
>bootloaders that do not implement this requirement, the uncompressed
>Image target is available instead.
>```

基本的意思是在arm64内核的下面不再默认提供解压工具，如果有需要需要在boot组件中实现。那么相应的，在AArch64 kernel image decompression的一封信件中，可以找到uboot的确是对aarch64这块重新做了支持[^7]。更多的工程师也倾向于拿掉内核的压缩和解压部分，甚至对uboot的uImage压缩提出了挑战设计。笔者认为，在arch64这样的高性能架构，已经无需在对vmlinux的大小做太多的考虑，可能只有在arch64一些size sensitive的情境下面才需要进行压缩。

而且，在linux kernel里面存在两个head.S也十分让人费解。在ARMv7的手册里还对这部分做了解释[^8]，arch/arm/boot/compressed/head.S和arch/arm/kernel/head.S，前者主要是对在early-boot阶段对zImage的解压，对vmlinux的还原。的确，去掉更好，更有助于消除内核歧义。

## 2.2 ARMv7

内核实际的启动节点是`start_kernel()`函数，在这个调用中再去调用100多个子函数执行linux的启动。但是调用start_kernel之前，也有一部分工作要处理：

*   必须对zImage进行解压
*   完成页目录构建（处理器列表、MMU目录建立、激活MMU）
*   检查处理器信息（atag信息有消息）

本章以ARMv7和ARMv8架构为例子，研究Linux内核启动前准备。

### 2.2.1 zImage pre-decompressed

zImage在开始前，需要对处理器进行一些初始化操作，为解压做一些准备。这个过程包含：中断禁止、分配动态内存、初始化BSS区、初始化页目录、打开cache等任务。然后后面会为解压数据进行空间数据（页目录空间）。

<div align='center'>
<img src="https://raw.githubusercontent.com/carloscn/images/main/typoratelegram-cloud-document-5-6206454177690813892.jpg" width="60%" />
</div>

#### 2.2.1.1 start标签

通过启动加载项完成对软硬件的默认初始化任务之后，最先执行的是`arch/arm/boot/compressed/head.S`，代码如下[arch/arm/boot/compressed/head.S](https://github.com/Xilinx/linux-xlnx/blob/master/arch/arm/boot/compressed/head.S#L192) 。start标签是第一个执行的代码，在start标签中，从启动加载项接手ID和atags的信息。此外，还会禁用中断及初始化寄存器，并跳转到[not_relocated](https://github.com/Xilinx/linux-xlnx/blob/master/arch/arm/boot/compressed/head.S#L192)标签(用于初始化bss)。

```
LCO -> r1
__bss_start -> r2
_end -> r3
zreladdr -> r4
_start -> r5
_got_start ->r6
_got_end -> ip
user_stack + 4096 -> sp
```

#### 2.2.1.2 bss系统域初始化- not_relocated标签

```assembly
not_relocated:	mov	r0, #0
1:		str	r0, [r2], #4		@ clear bss
		str	r0, [r2], #4
		str	r0, [r2], #4
		str	r0, [r2], #4
		cmp	r2, r3
		blo	1b

		/*
		 * Did we skip the cache setup earlier?
		 * That is indicated by the LSB in r4.
		 * Do it now if so.
		 */
		tst	r4, #1
		bic	r4, r4, #1
		blne	cache_on @将用于内核的动态内存空间起始地址
```

#### 2.2.1.3 激活缓存-cache_on

如果已经完成了bss区域的初始化和动态区域的设置，解压内核的最后准备就是执行cache_on。Linux中的cacheon的实现方式根据arm的机构版本不同是不同的。在cache_on标签中查找并调用当前系统ARM结构版本相符程序的子程序，另外，调用__setup_mmu子程序对页目录进行初始化。

```assembly
/*
 * Turn on the cache.  We need to setup some page tables so that we
 * can have both the I and D caches on.
 *
 * We place the page tables 16k down from the kernel execution address,
 * and we hope that nothing else is using it.  If we're using it, we
 * will go pop!
 *
 * On entry,
 *  r4 = kernel execution address
 *  r7 = architecture number
 *  r8 = atags pointer
 * On exit,
 *  r0, r1, r2, r3, r9, r10, r12 corrupted
 * This routine must preserve:
 *  r4, r7, r8
 */
		.align	5
cache_on:	mov	r3, #8			@ cache_on function
		b	call_cache_fn

/*
 * Initialize the highest priority protection region, PR7
 * to cover all 32bit address and cacheable and bufferable.
 */
__armv4_mpu_cache_on:
		mov	r0, #0x3f		@ 4G, the whole
		mcr	p15, 0, r0, c6, c7, 0	@ PR7 Area Setting
		mcr 	p15, 0, r0, c6, c7, 1

		mov	r0, #0x80		@ PR7
		mcr	p15, 0, r0, c2, c0, 0	@ D-cache on
		mcr	p15, 0, r0, c2, c0, 1	@ I-cache on
		mcr	p15, 0, r0, c3, c0, 0	@ write-buffer on

		mov	r0, #0xc000
		mcr	p15, 0, r0, c5, c0, 1	@ I-access permission
		mcr	p15, 0, r0, c5, c0, 0	@ D-access permission

		mov	r0, #0
		mcr	p15, 0, r0, c7, c10, 4	@ drain write buffer
		mcr	p15, 0, r0, c7, c5, 0	@ flush(inval) I-Cache
		mcr	p15, 0, r0, c7, c6, 0	@ flush(inval) D-Cache
		mrc	p15, 0, r0, c1, c0, 0	@ read control reg
						@ ...I .... ..D. WC.M
		orr	r0, r0, #0x002d		@ .... .... ..1. 11.1
		orr	r0, r0, #0x1000		@ ...1 .... .... ....

		mcr	p15, 0, r0, c1, c0, 0	@ write control reg

		mov	r0, #0
		mcr	p15, 0, r0, c7, c5, 0	@ flush(inval) I-Cache
		mcr	p15, 0, r0, c7, c6, 0	@ flush(inval) D-Cache
		mov	pc, lr

__armv3_mpu_cache_on:
		mov	r0, #0x3f		@ 4G, the whole
		mcr	p15, 0, r0, c6, c7, 0	@ PR7 Area Setting

		mov	r0, #0x80		@ PR7
		mcr	p15, 0, r0, c2, c0, 0	@ cache on
		mcr	p15, 0, r0, c3, c0, 0	@ write-buffer on

		mov	r0, #0xc000
		mcr	p15, 0, r0, c5, c0, 0	@ access permission

		mov	r0, #0
		mcr	p15, 0, r0, c7, c0, 0	@ invalidate whole cache v3
		/*
		 * ?? ARMv3 MMU does not allow reading the control register,
		 * does this really work on ARMv3 MPU?
		 */
		mrc	p15, 0, r0, c1, c0, 0	@ read control reg
						@ .... .... .... WC.M
		orr	r0, r0, #0x000d		@ .... .... .... 11.1
		/* ?? this overwrites the value constructed above? */
		mov	r0, #0
		mcr	p15, 0, r0, c1, c0, 0	@ write control reg

		/* ?? invalidate for the second time? */
		mcr	p15, 0, r0, c7, c0, 0	@ invalidate whole cache v3
		mov	pc, lr

#ifdef CONFIG_CPU_DCACHE_WRITETHROUGH
#define CB_BITS 0x08
#else
#define CB_BITS 0x0c
#endif
```

#### 2.2.1.4 页表项初始化 - __setup_mmu

__setup_mmu标签在cache_on标签内部调用，用于初始化解压内核的页表项。特别是对内存的256MB区域设置cacheable, bufferable，这是因为解压内核的时候，使用cache和writebuffer提高解压性能。

![image-20220705150241288](https://raw.githubusercontent.com/carloscn/images/main/typoraimage-20220705150241288.png)

```assembly
__setup_mmu:	sub	r3, r4, #16384		@ Page directory size
		bic	r3, r3, #0xff		@ Align the pointer
		bic	r3, r3, #0x3f00
/*
 * Initialise the page tables, turning on the cacheable and bufferable
 * bits for the RAM area only.
 */
		mov	r0, r3
		mov	r9, r0, lsr #18
		mov	r9, r9, lsl #18		@ start of RAM
		add	r10, r9, #0x10000000	@ a reasonable RAM size
		mov	r1, #0x12		@ XN|U + section mapping
		orr	r1, r1, #3 << 10	@ AP=11
		add	r2, r3, #16384
1:		cmp	r1, r9			@ if virt > start of RAM
		cmphs	r10, r1			@   && end of RAM > virt
		bic	r1, r1, #0x1c		@ clear XN|U + C + B
		orrlo	r1, r1, #0x10		@ Set XN|U for non-RAM
		orrhs	r1, r1, r6		@ set RAM section settings
		str	r1, [r0], #4		@ 1:1 mapping
		add	r1, r1, #1048576
		teq	r0, r2
		bne	1b
/*
 * If ever we are running from Flash, then we surely want the cache
 * to be enabled also for our execution instance...  We map 2MB of it
 * so there is no map overlap problem for up to 1 MB compressed kernel.
 * If the execution is in RAM then we would only be duplicating the above.
 */
		orr	r1, r6, #0x04		@ ensure B is set for this
		orr	r1, r1, #3 << 10
		mov	r2, pc
		mov	r2, r2, lsr #20
		orr	r1, r1, r2, lsl #20
		add	r0, r3, r2, lsl #2
		str	r1, [r0], #4
		add	r1, r1, #1048576
		str	r1, [r0]
		mov	pc, lr
ENDPROC(__setup_mmu)

@ Enable unaligned access on v6, to allow better code generation
@ for the decompressor C code:
__armv6_mmu_cache_on:
		mrc	p15, 0, r0, c1, c0, 0	@ read SCTLR
		bic	r0, r0, #2		@ A (no unaligned access fault)
		orr	r0, r0, #1 << 22	@ U (v6 unaligned access model)
		mcr	p15, 0, r0, c1, c0, 0	@ write SCTLR
		b	__armv4_mmu_cache_on

__arm926ejs_mmu_cache_on:
#ifdef CONFIG_CPU_DCACHE_WRITETHROUGH
		mov	r0, #4			@ put dcache in WT mode
		mcr	p15, 7, r0, c15, c0, 0
#endif

__armv4_mmu_cache_on:
		mov	r12, lr
#ifdef CONFIG_MMU
		mov	r6, #CB_BITS | 0x12	@ U
		bl	__setup_mmu
		mov	r0, #0
		mcr	p15, 0, r0, c7, c10, 4	@ drain write buffer
		mcr	p15, 0, r0, c8, c7, 0	@ flush I,D TLBs
		mrc	p15, 0, r0, c1, c0, 0	@ read control reg
		orr	r0, r0, #0x5000		@ I-cache enable, RR cache replacement
		orr	r0, r0, #0x0030
 ARM_BE8(	orr	r0, r0, #1 << 25 )	@ big-endian page tables
		bl	__common_mmu_cache_on
		mov	r0, #0
		mcr	p15, 0, r0, c8, c7, 0	@ flush I,D TLBs
#endif
		mov	pc, r12

__armv7_mmu_cache_on:
		enable_cp15_barriers	r11
		mov	r12, lr
#ifdef CONFIG_MMU
		mrc	p15, 0, r11, c0, c1, 4	@ read ID_MMFR0
		tst	r11, #0xf		@ VMSA
		movne	r6, #CB_BITS | 0x02	@ !XN
		blne	__setup_mmu
		mov	r0, #0
		mcr	p15, 0, r0, c7, c10, 4	@ drain write buffer
		tst	r11, #0xf		@ VMSA
		mcrne	p15, 0, r0, c8, c7, 0	@ flush I,D TLBs
#endif
		mrc	p15, 0, r0, c1, c0, 0	@ read control reg
		bic	r0, r0, #1 << 28	@ clear SCTLR.TRE
		orr	r0, r0, #0x5000		@ I-cache enable, RR cache replacement
		orr	r0, r0, #0x003c		@ write buffer
		bic	r0, r0, #2		@ A (no unaligned access fault)
		orr	r0, r0, #1 << 22	@ U (v6 unaligned access model)
						@ (needed for ARM1176)
#ifdef CONFIG_MMU
 ARM_BE8(	orr	r0, r0, #1 << 25 )	@ big-endian page tables
		mrcne   p15, 0, r6, c2, c0, 2   @ read ttb control reg
		orrne	r0, r0, #1		@ MMU enabled
		movne	r1, #0xfffffffd		@ domain 0 = client
		bic     r6, r6, #1 << 31        @ 32-bit translation system
		bic     r6, r6, #(7 << 0) | (1 << 4)	@ use only ttbr0
		mcrne	p15, 0, r3, c2, c0, 0	@ load page table pointer
		mcrne	p15, 0, r1, c3, c0, 0	@ load domain access control
		mcrne   p15, 0, r6, c2, c0, 2   @ load ttb control
#endif
		mcr	p15, 0, r0, c7, c5, 4	@ ISB
		mcr	p15, 0, r0, c1, c0, 0	@ load control register
		mrc	p15, 0, r0, c1, c0, 0	@ and read it back
		mov	r0, #0
		mcr	p15, 0, r0, c7, c5, 4	@ ISB
		mov	pc, r12

__fa526_cache_on:
		mov	r12, lr
		mov	r6, #CB_BITS | 0x12	@ U
		bl	__setup_mmu
		mov	r0, #0
		mcr	p15, 0, r0, c7, c7, 0	@ Invalidate whole cache
		mcr	p15, 0, r0, c7, c10, 4	@ drain write buffer
		mcr	p15, 0, r0, c8, c7, 0	@ flush UTLB
		mrc	p15, 0, r0, c1, c0, 0	@ read control reg
		orr	r0, r0, #0x1000		@ I-cache enable
		bl	__common_mmu_cache_on
		mov	r0, #0
		mcr	p15, 0, r0, c8, c7, 0	@ flush UTLB
		mov	pc, r12

__common_mmu_cache_on:
#ifndef CONFIG_THUMB2_KERNEL
#ifndef DEBUG
		orr	r0, r0, #0x000d		@ Write buffer, mmu
#endif
		mov	r1, #-1
		mcr	p15, 0, r3, c2, c0, 0	@ load page table pointer
		mcr	p15, 0, r1, c3, c0, 0	@ load domain access control
		b	1f
		.align	5			@ cache line aligned
1:		mcr	p15, 0, r0, c1, c0, 0	@ load control register
		mrc	p15, 0, r0, c1, c0, 0	@ and read it back to
		sub	pc, lr, r0, lsr #32	@ properly flush pipeline
#endif
```

# 3. 从zImage还原vmlinux(ARMv7 only)

Linux内核之前通过not_relocated和cache_on做好解压之前的准备工作，并且malloc了空间，做好了对vmlinux还原的准备。本节通过gunzip对压缩后的内核zImage执行解压，并调用与当前处理器的ARM结构对应的cache函数。最终将PC移动到zImage解压的位置，使解压之后的内核能够执行。

<div align='center'>
<img src="https://raw.githubusercontent.com/carloscn/images/main/typoratelegram-cloud-document-5-6208634934450456135.jpg" width="60%" />
</div>

**Note, gunzip位于内核源码[arch/arm/boot/compressed/misc.c](https://github.com/carloscn/imx-linux-4.1.15/blob/master/arch/arm/boot/compressed/misc.c)中。**

## 3.1 wont_overwrite

wont_overwrite在zImage准备解压的最后一项工作，在这个步骤里面，上一个阶段的需要传递参数过来。这里面有个知识点，**CONFIG_ZBOOT_ROM**[^9]。这项配置指示压缩的bootloader是不是在ROM/flash当中，根据文献[^11]，分为了两种模式，一种是PIC模式和ROM模式，PIC模式只有在RAM里面有相应的程序，load内核之后可能会把这部分程序覆盖；而ROM模式，将RAM和ROM地址分开，load内核之后不会将这部分程序覆盖。使用PIC模式直接CONFIG_ZBOOT_ROM=n即可。

>### Compressed boot loader in ROM/flash[^10]
>
>#### configname: CONFIG_ZBOOT_ROM
>
>Linux Kernel Configuration
>
>└─> Boot options
>
>└─> Compressed boot loader in ROM/flash
>
>Say Y here if you intend to execute your compressed kernel image
>(zImage) directly from ROM or flash. If unsure, say N.

```assembly
wont_overwrite:
/*
 * If delta is zero, we are running at the address we were linked at.
 *   r0  = delta
 *   r2  = BSS start
 *   r3  = BSS end
 *   r4  = kernel execution address (possibly with LSB set)
 *   r5  = appended dtb size (0 if not present)
 *   r7  = architecture ID
 *   r8  = atags pointer
 *   r11 = GOT start
 *   r12 = GOT end
 *   sp  = stack pointer
 */
		orrs	r1, r0, r5
		beq	not_relocated

		add	r11, r11, r0
		add	r12, r12, r0

#ifndef CONFIG_ZBOOT_ROM
		/*
		 * If we're running fully PIC === CONFIG_ZBOOT_ROM = n,
		 * we need to fix up pointers into the BSS region.
		 * Note that the stack pointer has already been fixed up.
		 */
		add	r2, r2, r0
		add	r3, r3, r0

		/*
		 * Relocate all entries in the GOT table.
		 * Bump bss entries to _edata + dtb size
		 */
1:		ldr	r1, [r11, #0]		@ relocate entries in the GOT
		add	r1, r1, r0		@ This fixes up C references
		cmp	r1, r2			@ if entry >= bss_start &&
		cmphs	r3, r1			@       bss_end > entry
		addhi	r1, r1, r5		@    entry += dtb size
		str	r1, [r11], #4		@ next entry
		cmp	r11, r12
		blo	1b

		/* bump our bss pointers too */
		add	r2, r2, r5
		add	r3, r3, r5

#else

		/*
		 * Relocate entries in the GOT table.  We only relocate
		 * the entries that are outside the (relocated) BSS region.
		 */
1:		ldr	r1, [r11, #0]		@ relocate entries in the GOT
		cmp	r1, r2			@ entry < bss_start ||
		cmphs	r3, r1			@ _end < entry
		addlo	r1, r1, r0		@ table.  This fixes up the
		str	r1, [r11], #4		@ C references.
		cmp	r11, r12
		blo	1b
#endif
```

要注意到，这部分程序的时候对GOT全局表进行了展开。

decompress_kernel是解压zImage的子程序，这样引导加载项（bootstrap loader）的所有操作基本结束，跳转到call kernel标签执行内核代码初始化操作。查看代码：https://elixir.bootlin.com/linux/v2.6.30.4/source/arch/arm/boot/compressed/head.S#L537

```assembly
call_kernel:	
        bl	cache_clean_flush
		bl	cache_off
		mov	r0, #0			@ must be zero
		mov	r1, r7			@ restore architecture number
		mov	r2, r8			@ restore atags pointer
		mov	pc, r4			@ call kernel
```

这部分已经在linux2.6.30+中去掉了。banch target cache是流水线中的指令cache，清除btc实际上是刷流水线。

第一步，是cache失效并刷回到ram里面；

第二步，关闭开始mmu，使cache和tlb失效，清除btc(branch target cache，分支目标缓存)。

第三部**，控制权移动到arch/arm/kernel/head.S中，正式执行内核初始化，并且把结构ID和atags指针作为传递参数。**

对于`__cache_off`，在linux这样处理：

```assembly
__armv4_mmu_cache_off:
		mrc	p15, 0, r0, c1, c0  @ 将control reg复制到r0
		bic	r0, r0, #0x000d     @ 清空0x000d -> 1101 0,2,3 bit位 
		mcr	p15, 0, r0, c1, c0	@ turn MMU and cache off
		mov	r0, #0
		mcr	p15, 0, r0, c7, c7	@ invalidate whole cache v4
		mcr	p15, 0, r0, c8, c7	@ invalidate whole TLB v4
		mov	pc, lr
```

**真正意义的cache off还需要invalidate所有的cache和TLB。**

# 4. 调用start_kernel(ARMv7/v8)

这个部分是调用start_kernel()函数的最后阶段。正式启动内核之前，先检查自身处理器的信息和机器信息的结构体的位置，确认从启动加载项接受的atag信息是不是有效。ARMv7和ARMv8有着不同的流程，我们需要在这里开始做出ARMv7和ARMv8两个处理器的分支划分。

## 4.1 ARMv7

如果自身处理器信息和机器有误，程序就立即结束。在检查完所有信息合法性的基础上，设置页表的MMU标识并激活，最终调用C代码编成start_kernel()内核起始函数。

<div align='center'>
<img src="https://raw.githubusercontent.com/carloscn/images/main/typoratelegram-cloud-document-5-6208634934450456159.jpg" width="80%" />
</div>

### 4.1.1 初始化指向 --- stext标签

通过引导加载项（该程序负责将压缩的内核加载到内存，并执行解压等内核启动所需的操作）加载内核之后，首先执行的部分就是stext。执行该标签时要求如下状态。

*   MMU = off
*   D-Cache = off
*   r0 = 0
*   r1 = machine number
*   r2 = atags pointer

在进入stext标签时候，首先转换armv7需要转换到**SVC模式（SVC_MODE）**，并禁止IRQ。然后调用合法性检查程序，主要针对于CPU和平台信息，并检查atag信息，追加设置页表之后启动MMU。

```assembly
/*
 * Kernel startup entry point.
 * ---------------------------
 *
 * This is normally called from the decompressor code.  The requirements
 * are: MMU = off, D-cache = off, I-cache = dont care, r0 = 0,
 * r1 = machine nr, r2 = atags pointer.
 *
 * This code is mostly position independent, so if you link the kernel at
 * 0xc0008000, you call this at __pa(0xc0008000).
 *
 * See linux/arch/arm/tools/mach-types for the complete list of machine
 * numbers for r1.
 *
 * We're trying to keep crap to a minimum; DO NOT add any machine specific
 * crap here - that's what the boot loader (or in extreme, well justified
 * circumstances, zImage) is for.
 */
	.section ".text.head", "ax"
ENTRY(stext)
	msr	cpsr_c, #PSR_F_BIT | PSR_I_BIT | SVC_MODE @ ensure svc mode
						@ and irqs disabled
	mrc	p15, 0, r9, c0, c0		@ get processor id
	bl	__lookup_processor_type		@ r5=procinfo r9=cpuid
	movs	r10, r5				@ invalid processor (r5=0)?
	beq	__error_p			@ yes, error 'p'
	bl	__lookup_machine_type		@ r5=machinfo
	movs	r8, r5				@ invalid machine (r5=0)?
	beq	__error_a			@ yes, error 'a'
	bl	__vet_atags
	bl	__create_page_tables

	/*
	 * The following calls CPU specific code in a position independent
	 * manner.  See arch/arm/mm/proc-*.S for details.  r10 = base of
	 * xxx_proc_info structure selected by __lookup_machine_type
	 * above.  On return, the CPU will be ready for the MMU to be
	 * turned on, and r0 will hold the CPU control register value.
	 */
	ldr	r13, __switch_data		@ address to jump to after
						@ mmu has been enabled
	adr	lr, __enable_mmu		@ return (PIC) address
	add	pc, r10, #PROCINFO_INITFUNC
ENDPROC(stext)
```

切换SVC模式，armv7通过下面的指令进行。

```assembly
msr	cpsr_c, #PSR_F_BIT | PSR_I_BIT | SVC_MODE @ ensure svc mode
					@ and irqs disabled
```

### 4.1.2 processor / machine and atags

**关键点：虚拟地址转物理地址**

如何搜寻的过程，这里暂时不整理，这部分可以参考《ARMLinux内核源码剖析》的第73页。这里有比较重要的处理是在禁用MMU的情况下，虚拟地址转化为物理地址的一个方法。程序走到这里的时候，由于禁用了MMU，因此无法通过虚拟地址访问内存。但是，保存处理器信息的区域地址__proc_info_begin和 _proc_info_end是编译的时候指定的，所以都是虚拟地址。因此，只有将这些虚拟地址转换为物理地址，才能正确的访问处理器新的的proc_info_list的结构体。

这里的做法是做偏移处理，将偏移的量放在一个寄存器里面，然后作为数值运算：

```assembly
virtual_address(__proc_info_begin) + offset = r5 + offset
											= physical_address(__proc_info_begin)
```

**关键点：atags**

Linux内核从启动加载项接受三个参数与。在ARM中循序AAPCS（procedure call stardard for the ARM architecture）标准的时候，少于4个的参数被分配在r0-r3之中，对于5个以上的参数，其前四个参数在r0-r3志宏，而之后的参数则进入栈。tagged list由struct tag数组组成，包含内存、视频、serial、initrd、revision、cmdline等信息。

<div align='center'>
<img src="https://raw.githubusercontent.com/carloscn/images/main/typoraimage-20220706135412281.png" width="40%" />
</div>

tagged list不得被内核解压器(decompresssor)或者bootp程序覆写（overwrite），因此主要位于RAM的第一个16KB。在uboot中可以查看bootm.c的setup_start_tag函数，已经setup_end_tag中设置的ATAG_CORE/NONE代码[^12]。

```c
struct tag_header {
		u32 size;	//结构体的大小
		u32 tag;	//结构体的类型
	};
struct tag {
       struct tag_header hdr;
		union { 	//此枚举体包含了uboot传给内核参数的所有类型
				struct tag_core         core;
				struct tag_mem32        mem;
				struct tag_videotext    videotext;
				struct tag_ramdisk      ramdisk;
				struct tag_initrd       initrd;
				struct tag_serialnr     serialnr;
				struct tag_revision     revision;
				struct tag_videolfb     videolfb;
				struct tag_cmdline      cmdline;
				/*
				* Acorn specific
				*/
				struct tag_acorn        acorn;
				/*
				 * DC21285 specific
				 */
				struct tag_memclk       memclk;
				struct tag_mtdpart      mtdpart_info;
		} u;
};
```

### 4.1.3 __create_page_tables

在打开MMU之前，Linux内核需要为MMU建立好页表。虚拟内存的作用我们在ARMv8的MMU管理中已经把整个历史go-through了一遍，在这里我们可以简单的再去复习一下。在32位操作系统中，处理器具有4G的虚拟内存，ARMv7架构是32位的处理器架构，在不开large memory的情况下最高也只能支持4GB的虚拟内存访问，这里的4GB虚拟内存指的并不是所有进程合在一起的内存为4G，而是每一个进程看到的都是4GB的虚拟地址空间。

这就是MMU的作用，MMU让每一个进程都有独占了所有内存的幻象。而这种技术的底层支持，也是来源于现代内存管理的方式——分页管理及换入换出技术。例如图中两个进程，被MMU映射到不同的物理地址页帧上面，两个进程无法感知对方的映射。

<div align='center'>
<img src="https://raw.githubusercontent.com/carloscn/images/main/typoraimage-20220706143248614.png" width="70%" />
</div>

而且这样的分页技术提供了一个好处，就是进程和进程之间的内存共享。通过MMU映射相同的物理页帧就可以达到这样的效果。__create_page_tables 中，需要创建一个16K大小的页表项（包含4096个虚拟地址和物理地址的映射关系），这个页表项也是在ram上面开辟的。

`__create_page_tables`中，KERNEL_RAM_PADDR相聚0x4000的位置（KERNEL_RAM_PADDR-0x4000）到KERNEL_RAM_PADDR所有页表项执行循环，并初始化为0。对相当于内核区域的项设置节区基址和cacheable，bufferable值。执行__create_page_tables之后的页表如图所示：

<div align='center'>
<img src="https://raw.githubusercontent.com/carloscn/images/main/typoraimage-20220706143603013.png" width="70%" />
</div>

```assembly
/*
 * Setup the initial page tables.  We only setup the barest
 * amount which are required to get the kernel running, which
 * generally means mapping in the kernel code.
 *
 * r8  = machinfo
 * r9  = cpuid
 * r10 = procinfo
 *
 * Returns:
 *  r0, r3, r6, r7 corrupted
 *  r4 = physical page table address
 */
__create_page_tables:
	pgtbl	r4				@ page table address

	/*
	 * Clear the 16K level 1 swapper page table
	 */
	mov	r0, r4
	mov	r3, #0
	add	r6, r0, #0x4000
1:	str	r3, [r0], #4
	str	r3, [r0], #4
	str	r3, [r0], #4
	str	r3, [r0], #4
	teq	r0, r6
	bne	1b

	ldr	r7, [r10, #PROCINFO_MM_MMUFLAGS] @ mm_mmuflags

	/*
	 * Create identity mapping for first MB of kernel to
	 * cater for the MMU enable.  This identity mapping
	 * will be removed by paging_init().  We use our current program
	 * counter to determine corresponding section base address.
	 */
	mov	r6, pc, lsr #20			@ start of kernel section
	orr	r3, r7, r6, lsl #20		@ flags + kernel base
	str	r3, [r4, r6, lsl #2]		@ identity mapping

	/*
	 * Now setup the pagetables for our kernel direct
	 * mapped region.
	 */
	add	r0, r4,  #(KERNEL_START & 0xff000000) >> 18
	str	r3, [r0, #(KERNEL_START & 0x00f00000) >> 18]!
	ldr	r6, =(KERNEL_END - 1)
	add	r0, r0, #4
	add	r6, r4, r6, lsr #18
1:	cmp	r0, r6
	add	r3, r3, #1 << 20
	strls	r3, [r0], #4
	bls	1b

#ifdef CONFIG_XIP_KERNEL
	/*
	 * Map some ram to cover our .data and .bss areas.
	 */
	orr	r3, r7, #(KERNEL_RAM_PADDR & 0xff000000)
	.if	(KERNEL_RAM_PADDR & 0x00f00000)
	orr	r3, r3, #(KERNEL_RAM_PADDR & 0x00f00000)
	.endif
	add	r0, r4,  #(KERNEL_RAM_VADDR & 0xff000000) >> 18
	str	r3, [r0, #(KERNEL_RAM_VADDR & 0x00f00000) >> 18]!
	ldr	r6, =(_end - 1)
	add	r0, r0, #4
	add	r6, r4, r6, lsr #18
1:	cmp	r0, r6
	add	r3, r3, #1 << 20
	strls	r3, [r0], #4
	bls	1b
#endif

	/*
	 * Then map first 1MB of ram in case it contains our boot params.
	 */
	add	r0, r4, #PAGE_OFFSET >> 18
	orr	r6, r7, #(PHYS_OFFSET & 0xff000000)
	.if	(PHYS_OFFSET & 0x00f00000)
	orr	r6, r6, #(PHYS_OFFSET & 0x00f00000)
	.endif
	str	r6, [r0]

#ifdef CONFIG_DEBUG_LL
	ldr	r7, [r10, #PROCINFO_IO_MMUFLAGS] @ io_mmuflags
	/*
	 * Map in IO space for serial debugging.
	 * This allows debug messages to be output
	 * via a serial console before paging_init.
	 */
	ldr	r3, [r8, #MACHINFO_PGOFFIO]
	add	r0, r4, r3
	rsb	r3, r3, #0x4000			@ PTRS_PER_PGD*sizeof(long)
	cmp	r3, #0x0800			@ limit to 512MB
	movhi	r3, #0x0800
	add	r6, r0, r3
	ldr	r3, [r8, #MACHINFO_PHYSIO]
	orr	r3, r3, r7
1:	str	r3, [r0], #4
	add	r3, r3, #1 << 20
	teq	r0, r6
	bne	1b
#if defined(CONFIG_ARCH_NETWINDER) || defined(CONFIG_ARCH_CATS)
	/*
	 * If we're using the NetWinder or CATS, we also need to map
	 * in the 16550-type serial port for the debug messages
	 */
	add	r0, r4, #0xff000000 >> 18
	orr	r3, r7, #0x7c000000
	str	r3, [r0]
#endif
#ifdef CONFIG_ARCH_RPC
	/*
	 * Map in screen at 0x02000000 & SCREEN2_BASE
	 * Similar reasons here - for debug.  This is
	 * only for Acorn RiscPC architectures.
	 */
	add	r0, r4, #0x02000000 >> 18
	orr	r3, r7, #0x02000000
	str	r3, [r0]
	add	r0, r4, #0xd8000000 >> 18
	str	r3, [r0]
#endif
#endif
	mov	pc, lr
ENDPROC(__create_page_tables)
	.ltorg
```

### 4.1.4 设置core（__v6_setup）标签

完成`__create_page_tables`之后，运行 `__v6_setup`程序设置当前处理器。根据不同的ARM架构，处理器初始化函数执行过程也是不一致的。vx的时候就调用vx_setup，调用之后就开始执行初始化任务。

setup的流程是： config_smp -> config_mmu

#### 4.1.4.1 config SMP

在ARM里面引入了cluster的概念，一个cluster内有多个相同处理器，在setup程序中会将SMP模式激活，并启动SCU（snoop control unit）（如果有的话）用于保持多个core之间的cache一致性。

除此之外，需要对cache机制进行使失效操作。哈佛体系结构和混合结构都可以执行初始化。清理所有的cache失效之后，清空写缓冲。清空操作中使用的协处理器命令是数据同步屏障（data synchronized barrier）。

使TLB失效之后，在寄存器TTB1中保存页表起始地址。最后，讲MMU、cache、分离预测这些功能设置值保存到寄存器r0中，并跳转到`__enable_mmu`。

#### 4.1.4.2 enable mmu

为了控制MMU的运行，使用协处理器15（CP15）的各个寄存器，控制CPc1寄存器将集成MMU控制系统中默认寄存器的作用。c1寄存器的部分位域如下所示：

![image-20220706150418298](https://raw.githubusercontent.com/carloscn/images/main/typoraimage-20220706150418298.png)

```assembly
/*
 * Setup common bits before finally enabling the MMU.  Essentially
 * this is just loading the page table pointer and domain access
 * registers.
 */
__enable_mmu:
#ifdef CONFIG_ALIGNMENT_TRAP
	orr	r0, r0, #CR_A
#else
	bic	r0, r0, #CR_A
#endif
#ifdef CONFIG_CPU_DCACHE_DISABLE
	bic	r0, r0, #CR_C
#endif
#ifdef CONFIG_CPU_BPREDICT_DISABLE
	bic	r0, r0, #CR_Z
#endif
#ifdef CONFIG_CPU_ICACHE_DISABLE
	bic	r0, r0, #CR_I
#endif
	mov	r5, #(domain_val(DOMAIN_USER, DOMAIN_MANAGER) | \
		      domain_val(DOMAIN_KERNEL, DOMAIN_MANAGER) | \
		      domain_val(DOMAIN_TABLE, DOMAIN_MANAGER) | \
		      domain_val(DOMAIN_IO, DOMAIN_CLIENT))
	mcr	p15, 0, r5, c3, c0, 0		@ load domain access register
	mcr	p15, 0, r4, c2, c0, 0		@ load page table pointer
	b	__turn_mmu_on
ENDPROC(__enable_mmu)

/*
 * Enable the MMU.  This completely changes the structure of the visible
 * memory space.  You will not be able to trace execution through this.
 * If you have an enquiry about this, *please* check the linux-arm-kernel
 * mailing list archives BEFORE sending another post to the list.
 *
 *  r0  = cp#15 control register
 *  r13 = *virtual* address to jump to upon completion
 *
 * other registers depend on the function called upon completion
 */
	.align	5
__turn_mmu_on:
	mov	r0, r0
	mcr	p15, 0, r0, c1, c0, 0		@ write control reg
	mrc	p15, 0, r3, c0, c0, 0		@ read id reg
	mov	r3, r3
	mov	r3, r3
	mov	pc, r13
ENDPROC(__turn_mmu_on)
```

在enable mmu的过程中，设置所需要的位激活MMU硬件，将访问寄存器和页表指针值加载到ARM处理器的寄存器。为寄存器r0设置与MMU相关的精简为，激活MMU硬件，使虚拟内存可用。

### 4.1.5 跳转start_kernel

从`__mmap_switched`标签开始，MMU处于激活装填，代码通过非PIC的绝对地址执行。从start_kernel开始，代码由C语言编写而成，因此需要`__switch_data`标签中设置的data\bss\stack值，并调用start_kernel后。`_switch_data`在[arch/arm/kernel/head-common.S](https://elixir.bootlin.com/linux/v2.6.30.4/source/arch/arm/kernel/head-common.S)中。

```assembly
	.type	__switch_data, %object
__switch_data:
	.long	__mmap_switched
	.long	__data_loc			@ r4
	.long	_data				@ r5
	.long	__bss_start			@ r6
	.long	_end				@ r7
	.long	processor_id			@ r4
	.long	__machine_arch_type		@ r5
	.long	__atags_pointer			@ r6
	.long	cr_alignment			@ r7
	.long	init_thread_union + THREAD_START_SP @ sp
```

```assembly
/*
 * The following fragment of code is executed with the MMU on in MMU mode,
 * and uses absolute addresses; this is not position independent.
 *
 *  r0  = cp#15 control register
 *  r1  = machine ID
 *  r2  = atags pointer
 *  r9  = processor ID
 */
__mmap_switched:
	adr	r3, __switch_data + 4

	ldmia	r3!, {r4, r5, r6, r7} @ AAAAAAAAAA_flag
	cmp	r4, r5				@ Copy data segment if needed
1:	cmpne	r5, r6           @ BBBBBBBBBBB_flag
	ldrne	fp, [r4], #4
	strne	fp, [r5], #4
	bne	1b

	mov	fp, #0				@ Clear BSS (and zero fp)
1:	cmp	r6, r7
	strcc	fp, [r6],#4
	bcc	1b

	ldmia	r3, {r4, r5, r6, r7, sp}
	str	r9, [r4]			@ Save processor ID
	str	r1, [r5]			@ Save machine type
	str	r2, [r6]			@ Save atags pointer
	bic	r4, r0, #CR_A			@ Clear 'A' bit
	stmia	r7, {r0, r4}			@ Save control register values
	b	start_kernel
ENDPROC(__mmap_switched)
```

*   AAAAAAAAA_flag位置，是将data_loc和data和bss_start，end变量保存的地址存入寄存器r4/r5/r6/r7
*   BBBBBBBBBBB_flag位置，是将data_loc和data值比较，如果不一致，则复制数据。data_loc指向二进制文件中初始化数据区域的起始位置，data指向内存中初始化数据区域其实位置。由于内核在ROM中通过XIP执行无法修改数据，因此将数据区域复制到RAM，使其能够修改。

## 4.2 ARMv8




# Ref

[^1]: [ARM Linux内核源码剖析](https://book.douban.com/subject/25918026/)
[^2]:[Linux Kernel Map](https://makelinux.github.io/kernel/map/)
[^3]:[几种linux内核文件的区别(vmlinux、zImage、bzImage、uImage、vmlinuz、initrd ) ](https://blog.csdn.net/hanxuefan/article/details/7454352)
[^4]:[Chapter 5 : Kernel Initialization ](https://hackmd.io/@3zUb5pYSS1W_VVsmvHE5MQ/BJroQrL-g?type=view)
[^5]:[Decompressed vmlinux: linux kernel initialization from page table configuration perspective](https://www.slideshare.net/AdrianHuang/decompressed-vmlinux-linux-kernel-initialization-from-page-table-configuration-perspective)
[^6]:[Booting AArch64 Linux](https://www.kernel.org/doc/Documentation/arm64/booting.txt)
[^7]:[AArch64 kernel image decompression](https://linux-arm-kernel.infradead.narkive.com/bcdVuTBY/aarch64-kernel-image-decompression)
[^8]:[ARM Cortex-A Series Programmer's Guide for ARMv7-A - Kernel entry](https://developer.arm.com/documentation/den0013/d/Boot-Code/Booting-Linux/Kernel-entry)
[^9]:[CONFIG_ZBOOT_ROM: Compressed boot loader in ROM/flash ](https://cateee.net/lkddb/web-lkddb/ZBOOT_ROM.html)
[^10]:[Linux Config Help - Compressed boot loader in ROM/flash ](https://www.kernelconfig.io/config_zboot_rom?q=&kernelversion=5.18.9&arch=arm)
[^11]:[[PATCH] Clean up ARM compressed loader](https://yhbt.net/lore/all/20100224084259.GA8068@pengutronix.de/T/)
[^12]:[uboot以tag方式给内核传参 ](https://blog.csdn.net/weixin_42031299/article/details/121239507)